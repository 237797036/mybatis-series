Mybatis：动态sql的支持，mybatis将sql交由开发者去控制，在sql的优化方面，开发者可以随心所欲。封装：操作db的过程、动态sql的拼装、结果和对象的映射。Mybatis核心对象介绍1.SqlSessionFactoryBuilder这个是一个构建器，通过名字大家也可以感觉到SqlSessionFactoryBuilder构建器，是用来构建SqlSessionFactory对象的，SqlSessionFactoryBuilder可以通过读取mybatis的配置文件，然后构建一个SqlSessionFactory对象，一个项目中有很多mapper xml文件，如果每次操作都去重新解析是非常慢的，那么怎么办？能不能第一次解析好然后放在内存中，以后直接使用，SqlSessionFactoryBuilder就是搞这个事情的，将mybatis配置文件、mapper xml文件、mapper xml文件和Mapper 接口的映射关系，这些都先给解析好，然后放在java对象中，java对象存在于内存中，内存中访问会非常快的，那么我们每次去用的时候就不需要重新去解析xml了，SqlSessionFactoryBuilder解析配置之后，生成的对象就是SqlSessionFactory，这个是一个重量级的对象，创建他是比较耗时的，所以一般一个db我们会创建一个SqlSessionFactory对象，然后在系统运行过程中会一直存在，而SqlSessionFactoryBuilder用完了就可以释放了。2.SqlSessionFactory通过名字可以知道，这个是一个工厂，是用来创建SqlSession的工厂，SqlSessionFactory是一个重量级的对象，一般一个db对应一个SqlSessionFactory对象，系统运行过程中会一直存在。SqlSessionFactory是一个接口，这个接口有2个实现DefaultSqlSessionFactory和SqlSessionManager，一般都是通过SqlSessionFactoryBuilder来创建SqlSessionFactory对象。通过SqlSessionFactoryBuilder来创建SqlSessionFactory对象主要有2种方式，一种通过读取mybatis配置文件的方式，另外一种是硬编码的方式，这个后面会专门抽一篇文件介绍这块，springboot中会使用到硬编码的方式，所以这块会详细介绍。3.SqlSession我们通过jdbc操作数据库需要先获取一个Connection连接，然后拿着这个连接去对db进行操作，在mybatis中SqlSession就类似于jdbc中Connection连接对象，在mybatis中叫做Sql会话对象，一般我们一个db操作使用一个SqlSession对象，所以这个对象一般是‘方法级别’的，方法结束之后，这个对象就销毁了，这个对象可以调用sqlSessionFactory.openSession的方法来进行获取。我们可以直接通过SqlSession对象来调用mapper xml中各种db操作，需要指定具体的操作的id，id的格式为namespace.操作的id。4.Mapper接口我们可以通过SqlSession直接调用mapper xml中的db操作，不过更简单的以及推荐的方式是使用Mapper接口，Mapper接口中的方法和mapper xml文件中的各种db操作建立了映射关系，是通过Mapper接口完整名称+方法名称和mapper xml中的namespace+具体操作的id来进行关联的，然后我们直接调用Mapper接口中的方法就可以间接的操作db了，使用想当方便，Mapper接口需要通过SqlSession获取，传入Mapper接口对应的Class对象，然后会返回这个接口的实例，如：UserMapper mapper = sqlSession.getMapper(UserMapper.class);为什么需要Mapper接口？如果使用SqlSession接口中的方法完成db操作，会很麻烦：int insert(String statement, Object parameter);int update(String statement, Object parameter);int delete(String statement, Object parameter);<E> List<E> selectList(String statement);1.调用这些方法，需要明确知道statement的值，statement的值为namespace.具体操作的id，这些需要打开Mapper xml中去查看了才知道，写起来不方便2.parameter参数都是Object类型的，我们根本不知道这个操作具体类型是什么，需要查看Mapper xml才知道，随便传递个值，可能类型不匹配，但是只有在运行的时候才知道有问题3.selectList方法返回的是一个泛型类型的，通过这个方法我们根本不知道返回的结果的具体类型，也需要去查看Mapper xml才知道Mapper接口使用时注意点：Mapper接口的完整类名必须和对应的Mapper xml中的namespace的值一致Mapper接口中方法的名称需要和Mapper xml中具体操作的id值一致Mapper接口中方法的参数、返回值可以不和Mapper xml中的一致Mapper接口的原理：（重点）使用java中的动态代理实现，‘mybatis启动’的时候会加载全局配置文件mybatis-config.xml，然后解析这个文件中的mapper元素指定的UserMapper.xml，会根据UserMapper.xml的namespace的值'创建这个接口的一个动态代理'，主要使用java中的Proxy实现的，使用java.lang.reflect.Proxy类中的newProxyInstance方法，我们可以创建任意一个接口的一个代理对象：当调用UserMapper接口的方法的时候，会调用到UserMapperProxy代理对象的invoke方法。public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);Mybatis中创建Mapper接口代理对象使用：MapperProxyFactory<T>为什么需要使用别名?parameterType="com.xxx.domain.UserModel"参数的类型resultType="com.xxx.UserModel"返回值的类型完整的类名，比较长。可以给某个类型起一个别名注册别名的3中方式：<typeAliases>    <typeAlias type="完整的类型名称" alias="别名" /></typeAliases>如果有很多类需要注册，需要写很多#typeAlias#配置通过packege元素批量注册<typeAliases>    <package name="指定一个包名"/></typeAliases>mybatis会加载这个包以及子包中所有的类型，给这些类型都注册别名，别名名称默认会采用类名小写的方式，如UserModel的别名为usermodel方式2中通过package可以批量注册别名，如果指定的包中包含了多个类名相同的类，会怎么样呢？package结合@Alias批量注册并指定别名别名不区分大小写别名的原理：通过一个名称访问某种类型时，mybatis先在别名和类型映射的map中按照key进行查找，如果找到了直接返回对应的类型，如果没找到，会将这个名称当做完整的类名去解析成Class对象，如果这2步解析都无法识别这种类型，就会报错。别名相关的操作都位于org.apache.ibatis.type.TypeAliasRegistry类中，包含别名的注册、解析等各种操作经常使用${属性名称}引用属性的值mybatis这块的源码在org.apache.ibatis.builder.xml.XMLConfigBuilder#propertiesElement方法引入mapper xml文件方式1：使用mapper resouce属性注册mapper xml文件方式2：使用mapper class属性注册Mapper接口，mybais会去加载class对应的接口，然后还会去加载和这个接口同一个目录的同名的xml文件如果编译之后的文件中少了UserMapper.xml，这个和maven有关，maven编译src/java代码的时候，默认只会对java文件进行编译然后放在target/classes目录，需要在pom.xml中加入下面配置：<build>    <resources>        <resource>            <directory>${project.basedir}/src/main/java</directory>            <includes>                <include>**/*.xml</include>            </includes>        </resource>        <resource>            <directory>${project.basedir}/src/main/resources</directory>            <includes>                <include>**/*</include>            </includes>        </resource>    </resources></build>方式3：使用package元素批量注册Mapper接口<mappers>    <package name="需要扫描的包" /></mappers>注册mapper接口和xml文件的源码：org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElementmybatis全局配置文件中的元素是在如下dtd配置文件中定义的。（元素有先后顺序）http://mybatis.org/dtd/mybatis-3-config.dtdMybatis解析这个配置文件的入口是在下面的方法中：org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfigurationmybatis启动的时候会按顺序加载上面的标签详解mapper接口传参：1传递一个参数（#{任意合法名称} 都可）2传递一个Map参数3传递一个javabean参数（常用）4传递多参数时，用@param指定参数名称   （如果不指定，则会受java编译时对参数名称的处理的影响）（#{arg0}、#{arg1} 或 #{param1}、#{param2}）javac命令有个-parameters参数，当编译代码时加上此参数，方法的实际名称会被编译到class字节码文件中，通过反射获取方法名称时就不是arg0、arg1这种格式了，而是真实的参数名称。方法参数名称不管怎么变，编译方式如何变化，param1, param2始终可用，这个param1, param2就是为了应对不同的编译方式而导致的参数名称发生变化。sql中使用param1、param2、paramN这种方式来引用多参数，对参数的顺序依赖性特别强，如果有人把参数的顺序或者参数的个数调整了，后果就是灾难性的，所以这种方式不建议使用。5传递1个Collection参数（collection）6传递1个List参数（List类型的参数会被放在map中，可以通过2个key（collection和list）都可以引用到这个List对象。）7传递1个数组参数（array）8.ResultHandler#作为参数当传递的参数类型是java.util.Collection的时候，会被放在map中，key为collection，value为参数的值所以在mapper xml中使用的使用时，需要通过‘collection’名称来引用Collection类型的参数集合参数，mybatis会进行一些特殊处理，源码在下面的方法中：org.apache.ibatis.session.defaults.DefaultSqlSession#wrapCollection判断参数是否是java.util.Collection类型，如果是，会放在map中，key为collection。如果参数是java.util.List类型的，会在map中‘继续’放一个list作为key来引用这个对象。如果参数是数组类型的，会通过array来引用这个对象。public interface ResultHandler<T> {  void handleResult(ResultContext<? extends T> resultContext);}public interface ResultContext<T> {  T getResultObject(); //获取当前行的结果  int getResultCount(); //获取当前结果到第几行了  boolean isStopped();  void stop();}ResultContext接口有一个实现类#org.apache.ibatis.executor.result.DefaultResultContext案例：遍历t_user表的所有记录，第2条遍历结束之后，停止遍历void getList(ResultHandler<UserModel> resultHandler);mybatis增删改的返回值要么是调用jdbc中的java.sql.Statement的executeUpdate的方法，要么是调用java.sql.PreparedStatement的executeUpdate方法增删改的返回值都是int，表示影响的行数，比如插入成功1行返回结果就是1，删除了10行记录，返回就是10，更新了5行记录，返回的就是5。jdbc执行增删改默认返回int类型，那mybatis当然也支持这个类型，但是mybatis的返回值比jdbc更强大，对于增删改还支持下面几种类型：intIntegerlong LongbooleanBooleanvoidmybatis内部将jdbc返回的int类型转换为上面指定的类型源码org.apache.ibatis.binding.MapperMethod#rowCountResult当我们没有指定id，或者指定的id为null的时候，mysql会自动生成id的值。jdbc获取主键的几种方式方式1：jdbc内置的方式jdbc的api中为我们提供了获取自动生成主键的值。具体在方法：java.sql.Statement.getGeneratedKeys()ResultSet getGeneratedKeys() throws SQLException;PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);ResultSet generatedKeys = preparedStatement.getGeneratedKeys();方式2：插入之后查询获取SELECT LAST_INSERT_ID可以在插入之后，立即使用当前连接发送上面这条sql去获取自增列的值就可以ResultSet rs = connection.prepareStatement("SELECT LAST_INSERT_ID()").executeQuery();方式3：插入之前获取oracle中没有mysql中自动增长列，但是oracle有个'序列'可以实现自动增长，序列有个初始值，每次递增的步长，可以获取序列的当前值、下一个值1.先定义一个序列2.获取下一个值：SELECT 序列名.NEXTVAL FROM dual;1.通过jdbc执行`SELECT 序列名.NEXTVAL FROM dual`获取序列的下一个值，如nextId2.在代码中使用nextId的值mybatis获取主键的3种方式：方式1：内部使用jdbc内置的方式<insert id="insertUser1" parameterType="com.xxx.domain.UserModel" useGeneratedKeys="true" keyProperty="id">最后插入成功之后，mybatis会通过反射将自增值设置给#keyProperty#指定的这个属性方式2：插入后/前，查询获取主键插入之后通过查询获取主键的值然后填充给指定的属性<insert id="insertUser1" parameterType="com.xxx.domain.UserModel" useGeneratedKeys="true" keyProperty="id">	<selectKey keyProperty="id" order="AFTER" resultType="long">		SELECT LAST_INSERT_ID()	</selectKey></insert>selectKey包含的sql，可以在插入之前或者插入之后运行mybatis处理自动生产主键值的代码，主要看下面这个接口：org.apache.ibatis.executor.keygen.KeyGeneratorpublic interface KeyGenerator {  void processBefore(Executor executor, MappedStatement ms, Statement stmt, Object parameter);  void processAfter(Executor executor, MappedStatement ms, Statement stmt, Object parameter);}这个接口默认有3个实现类：org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator#mybatis中获取主键的第一种方式org.apache.ibatis.executor.keygen.SelectKeyGenerator#其他2种方式org.apache.ibatis.executor.keygen.NoKeyGenerator单表查询：mapper xml中有个更强大的元素resultMap，通过这个元素可以定义查询结果的映射关系建议:mybatis为我们提供了强大的关联查询，不过个人建议尽量少用，最好是采用单表的方式查询，在程序中通过多次查询，然后自己对结果进行组装。Model中最好只定义一些和单表字段关联的属性，不要掺杂着其他对象的引用。为了系统健壮，不建议开启自动映射自动映射一种是全局的配置，对应用中所有的resultMap起效,在mybatis配置文件中进行设置；一种是通过resultMap的autoMapping属性autoMapping进行配置当开启自动映射之后，当sql的列名和Model中的字段名称是一样的时候（不区分大小写），mybatis内部会进行自动映射，不需要手动去写上面的4行映射规则<settings></settings>settings元素中有很多配置，这些配置最后都会被解析成#org.apache.ibatis.session.Configuration#的属性，源码位于org.apache.ibatis.builder.xml.XMLConfigBuilder#settingsElement()延迟加载：将数据加载时机推迟，比如推迟嵌套查询的执行时机，在mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的用户信息或者订单详情信息等，这种情况需要一种机制，当需要查看关联的数据时，再去执行对应的查询，返回需要的结果，这种需求在mybatis中可以使用延迟加载机制来实现。延迟加载设置方式：全局配置的方式#会对所有关联查询起效sqlmap中配置的方式<settings>    <!--打开延迟加载的开关  -->    <setting name="lazyLoadingEnabled" value="true"/>    <!-- 当为true的时候，调用任意延迟属性，会去加载所有延迟属性，如果为false，则调用某个延迟属性的时候，只会加载指定的属性 -->    <setting name="aggressiveLazyLoading" value="true"/></settings>调用的是获取用户信息，而订单列表信息也被加载了，这个主要是由于aggressiveLazyLoading被设置为true，当使用到一个延迟加载的属性时，其他延迟加载的属性也会被一起加载，所以触发了2个关联的查询。关联查询，一般我们使用association、collection，这两个元素都有个属性fetchType，通过这个属性可以指定关联查询的加载方式。fetchType值有2种，eager：立即加载；lazy：延迟加载。鉴别器(discriminator)一个查询可能会返回多个不同的结果集，类似于Java 语言中的 switch 语句<resultMap >    <id column="id" property="id"/>    <result column="up_time" property="upTime"/>    <!-- 鉴别器 -->    <discriminator javaType="int" column="id">        <case value="1">            <!--通过用户id查询用户信息-->            <association property="userModel" select="com.xxx.mapper.UserMapper.getById1" column="user_Id"/>        </case>        <case value="2">            <!--通过用户id查询用户信息-->            <association property="userModel" select="com.xxx.mapper.UserMapper.getById1" column="user_Id"/>            <!--通过订单id查询订单列表-->            <collection property="orderDetailModelList" select="com.xxx.mapper.OrderDetailMapper.getListByOrderId1" column="id"/>        </case>    </discriminator></resultMap>在resultMap中使用extends(继承)，可以重用其他resultMap中配置的映射关系。<resultMap extends="被继承的resultMap的id"></resultMap>mybatis中各种动态sql（无须在java代码中搞很多判断去拼接sql）#{}、${}#{}:为参数占位符?，即sql预编译，相当于使用jdbc中的PreparedStatement中的sql占位符，可以防止sql注入${}:为字符串替换， 即字符串拼接，不能访问sql注入。(mybatis会对$包含部分进行sql替换)动态sql1.if元素  #当test成立的时候，if体内部的sql会被拼接上。2.choose/when/otherwise元素  #相当于java中的if..else if..else  #当所有条件都不满足时，otherwise将起效	3.where元素（重要）mybatis中通过where 元素来解决（人为代码where 1=1），当使用where元素时，mybatis会将where内部拼接的sql进行处理，将这部分sql前面的AND 或者 OR去掉，并在前面追加一个where    <where>        <if test="id!=null">            AND id = #{id}        </if>    </where>	4.set元素（重要）	UPDATE t_user SET name = ?, age = ?, where id = ?where前面多了一个逗号，这个逗号是最后一个需要更新的字段后面的逗号，得去掉，mybatis中提供了set元素来解决。    <set>        <if test="name!=null">            name = #{name},        </if>        <if test="age!=null">            age = #{age},        </if>    </set>5.trim元素（比较强大）<trim prefix="" prefixOverrides="" suffix="" suffixOverrides=""></trim>源码：org.apache.ibatis.scripting.xmltags.TrimSqlNode5.foreach元素相当于java中的循环，可以用来遍历数组、集合、map等。<foreach collection="需要遍历的集合" item="集合中当前元素" index="" open="" separator="每次遍历的分隔符" close="">	动态sql部分</foreach>6.sql/include元素这两2个元素一般进行配合使用，可以实现代码重用的效果。<sql id="sql片段id">	各种动态sql</sql>其他地方需要使用的时候需要通过include关键字进行引入：<include refid="需要引入的sql片段的id"/>refid的值为mapper xml的namespace的值.sql的id，如果在同一个mapper中，namespace可以省略，直接写对应的sql的id就可以了，如：<include refid="findSql"/><include refid="com.xxx.mapper.UserMapper.findSql"/>7.bind元素bind元素允许我们通过ognl表达式在上下文中'定义'一个变量，最后在动态sql中可以使用这个变量。<if test="likeName!=null and likeName.trim()!=''">  <bind name="nameLike" value="'%'+ likeName.trim() +'%'" />  AND name like #{nameLike}</if>mybatis内部参数设置和结果的处理当我们使用mybatis插入用户信息的时候，mybatis底层也会调用PreparedStatement的这些设置参数的方法，mybatis底层是如何判断调用哪个方法的呢？是调用setInt方法还是setString方法的呢？答：通过mybatis中类型转换器1 参数设置，即设置参数的时候需要调用PreparedStatement中哪个set方法去设置参数，比如：插入用户信息id字段，id字段是java中的Integer类型的，mybatis内部知道需要调用setInt方法去给id字段设置参数。2将sql查询结果转换为对应的java类型，即调用ResultSet中的哪个get方法去获取参数，比如：id在数据中是int类型的，读取时会调用ResultSet的getInt方法，而name字段在db中是varchar类型的，读取时会调用getString方法去读取，而不是调用getInt方法去读取类型转换器接口：public interface TypeHandler<T> {  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;  T getResult(ResultSet rs, String columnName) throws SQLException;  T getResult(ResultSet rs, int columnIndex) throws SQLException;  T getResult(CallableStatement cs, int columnIndex) throws SQLException;}mybatis内部默认实现了很多类型转换器，基本上够我们用，比如IntegerTypeHandler转换器每种类型转换器能够处理哪些java类型以及能够处理的JdbcType的类型，这些都在#TypeHandlerRegistry#进行注册自定义类型转换器1 自定义类型转换器，继承BaseTypeHandler2 将自定义类型转换器注册到mybatis中，需要在mybatis配置文件中通过typeHandler元素进行引入3 在mapper xml中就可以使用了变通：（实体类可保持和db一样的类型，比如int）举例 查询：实体类：private SexEnum sex;数据库： sex SMALLINT@a 需自定义一个类型转换器SexEnumTypeHandle，用来处理db sex int字段和java SexEnum枚举之间的相互转换.class SexEnumTypeHandle extends BaseTypeHandler<SexEnum>@b 在mybatis配置文件中加入：<typeHandlers>    <typeHandler handler="com.xxx.typehandle.SexEnumTypeHandle"/></typeHandlers>举例 插入：map.put("sex", SexEnum.WOMAN);当不传递sex的值，或者sex传递为null，此时mybatis是无法判断map中sex对应的具体类型，无法找到具体用哪个类型转换器给sex设置参数，在mysql中不会报错，但是在oracle中会报错。1 可通过typeHandler属性明确指定参数的类型转换器<insert id="insert1" parameterType="map">    insert into t_user (id,name,age,sex)    VALUE (#{id},#{name},#{age},#{sex,typeHandler=com.xxx.typehandle.SexEnumTypeHandle})</insert>2 也可通过javaType属性来指定参数的具体类型<insert id="insert1" parameterType="map">    insert into t_user (id,name,age,sex)    VALUE (#{id},#{name},#{age},#{sex,javaType=com.xxx.enums.SexEnum})</insert>mybatis中的缓存：（重要）1 一、二级缓存访问顺序：一二级缓存都存在的情况下，会先访问二级缓存，然后再访问一级缓存，最后才会访问db（重点）2 将mapper xml中select元素的 #flushCache# 属性置为true，最终会清除一级缓存所有数据，同时也会清除这个‘namespace对应的二级缓存’3 将mapper xml中select元素的 #useCache# 置为false，会使这个查询跳过二级缓存，但不会清除二级缓存缓存可以加快数据的访问速度。比如我们从db中获取数据，要经过db server从磁盘读取数据耗时、网络传输耗时等，如果这些数据直接放在jvm对应的内存中，访问是不是会快很多。mybatis中分为一级缓存和二级缓存一级缓存：是SqlSession（连接，或者方法）级别的缓存，在操作数据库时需要构造sqlSession对象，在对象中有一个（HashMap）用于存储缓存数据，	不同的sqlSession之间的缓存数据区域（HashMap）互不影响二级缓存：是mapper（接口）级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存‘跨SqlSession’一级缓存是SqlSession级别的缓存，每个SqlSession都有自己单独的一级缓存，多个SqlSession之间的一级缓存相互隔离，互不影响，mybatis中一级缓存‘默认开启’一级缓存工作原理：在“同一个SqlSession”去多次去执行‘同样的查询’，每次执行的时候会先到一级缓存中查找，如果缓存中有就直接返回，如果一级缓存中没有相关数据，mybatis就会去db中进行查找，然后将查找到的数据放入一级缓存中，第二次执行同样的查询的时候，会发现缓存中已经存在了，会直接返回。一级缓存的存储介质是内存，是用一个HashMap来存储数据的，所以访问速度是非常快的。1.一级缓存是SqlSession级别的，每个人SqlSession有自己的一级缓存，不同的SqlSession之间一级缓存是相互隔离的2.mybatis中一级缓存默认是自动开启的3.当在同一个SqlSession中执行同样的查询的时候，会先从一级缓存中查找，如果找到了直接返回，如果没有找到会去访问db，然后将db返回的数据丢到一级缓存中，下次查询的时候直接从缓存中获取4.一级缓存清空的3种方式	a：同一个SqlSession中执行增删改会使一级缓存失效；	b：调用SqlSession.clearCache方法会使一级缓存失效；	c：Mapper xml中的select元素的flushCache属性置为true，‘会使一级缓存失效’（重要）一级缓存有局限性，必须要在‘同一个SqlSession’中执行‘同样的查询’，一级缓存才能提升查询速度，如果‘想在不同的SqlSession之间’使用缓存来加快查询速度，此时需要用二级缓存二级缓存是mapper级别的缓存，每个mapper xml有个namespace，‘二级缓存和namespace绑定’（重点），每个namespace关联一个二级缓存，多个SqlSession可以共用二级缓存，二级缓存跨SqlSessiona二级缓存默认没有开启，需要在mybatis全局配置文件中进行开启：<settings>    <!-- 开启二级缓存 -->    <setting name="cacheEnabled" value="true"/></settings>b还需要在对应的mapper xml加上：<cache/>（这个mapper xml中所有的查询都默认开启了二级缓存）一二级缓存如果都开启，数据查询过程如下：(重要)1 当发起一个查询的时候，mybatis会先访问这个namespace对应的二级缓存，如果二级缓存中有数据则直接返回，否则继续向下2 查询一级缓存中是否有对应的数据，如果有则直接返回，否则继续向下3 访问db获取需要的数据，然后放在当前SqlSession对应的一级缓存，并且在本地内存中的另外一个地方存储一份（这个地方我们就叫TransactionalCache）4 当SqlSession关闭的时候，即调用SqlSession的close()方法时，此时会将TransactionalCache中的数据放到二级缓存中，并且会清空当前SqlSession一级缓存清空或者跳过二级缓存的3种方式：1 对应的mapper中执行增删改，会清空二级缓存2 select元素的flushCache属性置为true，最终会清除一级缓存所有数据，同时会清除这个select所在的namespace对应的二级缓存中数据，然后再去db中查询数据3 select元素的useCache属性置为false，可以使‘这个查询’跳过二级缓存，然后去查询db，但不会清除二级缓存数据